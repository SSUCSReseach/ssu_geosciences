import numpy as np
from PIL import Image

import os
import os.path

import shutil


import config # config file we need to load our params from

def display_image(img, label):
        plt.imshow(img)
        print(label)
        plt.show()

def print_shapes(X_train, Y_train, X_dev, Y_dev, X_test, Y_test):
        print ("number of training examples = " + str(X_train.shape[0]))
        print ("number of dev examples = " + str(X_dev.shape[0]))
        print ("number of test examples = " + str(X_test.shape[0]))
        print ("X_train shape: " + str(X_train.shape))
        print ("Y_train shape: " + str(Y_train.shape))
        print ("X_dev shape : " + str(X_dev.shape))
        print ("Y_dev shape : " + str(Y_dev.shape))
        print ("X_test shape : " + str(X_test.shape))
        print ("Y_test shape : " + str(Y_test.shape))


def load_images(folder, img_size):
        '''
        return an array containing all the images from the given folder.
        all images are converted to RGB in channel_last format, and resized
        to img_size x img_size
        '''
        images = []
        for filename in os.listdir(folder):
                img = Image.open(os.path.join(folder, filename))
                if img is not None:
                        rbgimg = Image.new("RGB", img.size)
                        rbgimg.paste(img)
                        rbgimg = rbgimg.resize((img_size, img_size), Image.ANTIALIAS)
                        np_img = np.array(rbgimg)
                        images.append(np_img)

        return images


def load_dataset(image_directory, img_size, ratio_train = 0.6, ratio_dev = -1, ratio_test = -1,
                 verbose = False):

        assert(ratio_train > 0)
        assert(ratio_train < 1 and ratio_dev < 1 and ratio_test < 1)
        assert(ratio_train + ratio_dev + ratio_test <= 1)

        
        if ratio_dev < 0 and ratio_test < 0:
                ratio_dev = ratio_test = (1 - ratio_train) / 2
        elif ratio_dev < 0:
                ratio_dev = 1 - ratio_train - ratio_test
        elif ratio_test < 0:
                ratio_test = 1 - ratio_train - ratio_dev
                
        assert(ratio_train + ratio_dev + ratio_test == 1)
        
        x_with = np.array(load_images(image_directory + "/with", img_size))
        x_without = np.array(load_images(image_directory + "/without", img_size))
        y_with = np.ones((x_with.shape[0], 1))
        y_without = np.zeros((x_without.shape[0], 1))
        Y_images = np.concatenate((y_with, y_without))
        X_images = np.concatenate((x_with, x_without))
        
        # setup the training set
        num_train_X_with = int(x_with.shape[0] * ratio_train)
        x_train_with = x_with[0:num_train_X_with]
        num_train_X_without = int(x_without.shape[0] * ratio_train)
        x_train_without = x_without[0:num_train_X_without]
        x_train = np.concatenate((x_train_with, x_train_without))
        
        num_train_Y_with = int(y_with.shape[0] * ratio_train)
        y_train_with = y_with[0:num_train_Y_with]
        num_train_Y_without = int(y_without.shape[0] * ratio_train)
        y_train_without = y_without[0:num_train_Y_without]
        y_train = np.concatenate((y_train_with, y_train_without))
        
        # setup the dev set
        num_dev_x_with = int(x_with.shape[0] * ratio_dev)
        x_dev_with = x_with[num_train_X_with:num_train_X_with + num_dev_x_with]
        num_dev_x_without = int(x_without.shape[0] * ratio_dev)
        x_dev_without = x_without[num_train_X_without:num_train_X_without + num_dev_x_without]
        x_dev = np.concatenate((x_dev_with, x_dev_without))
        
        num_dev_y_with = int(y_with.shape[0] * ratio_dev)
        y_dev_with = y_with[num_train_Y_with:num_train_Y_with + num_dev_y_with]
        num_dev_y_without = int(y_without.shape[0] * ratio_dev)
        y_dev_without = y_without[num_train_Y_without:num_train_Y_without + num_dev_y_without]
        y_dev = np.concatenate((y_dev_with, y_dev_without))

        # setup the test set
        num_test_x_with = int(x_with.shape[0] * ratio_test)
        x_test_with = x_with[num_train_X_with + num_dev_x_with:x_with.shape[0]]
        num_test_x_without = int(x_without.shape[0] * ratio_test)
        x_test_without = x_without[num_train_X_without + num_dev_x_without:x_without.shape[0]]
        x_test = np.concatenate((x_test_with, x_test_without))
        
        num_test_y_with = int(y_with.shape[0] * ratio_test)
        y_test_with = y_with[num_train_Y_with + num_dev_y_with:y_with.shape[0]]
        num_test_y_without = int(y_without.shape[0] * ratio_test)
        y_test_without = y_without[num_train_Y_without + num_dev_y_without:y_without.shape[0]]
        y_test = np.concatenate((y_test_with, y_test_without))

        if verbose:
                print('train/dev/test ratios : ' + str(ratio_train) + ', ' + str(ratio_dev) + ', ' + str(ratio_test))
                print('x_images shape: ' + str(X_images.shape))
                print('y_images shape: ' + str(Y_images.shape))
                print('x_train shape: ' + str(x_train.shape))
                print('y_train shape: ' + str(y_train.shape))
                print('x_dev shape: ' + str(x_dev.shape))
                print('y_dev shape: ' + str(y_dev.shape))
                print('x_test shape: ' + str(x_test.shape))
                print('y_test shape: ' + str(y_test.shape))

        # check to ensure our sizes match
        assert(X_images.shape[0] == (x_train.shape[0] + x_dev.shape[0] + x_test.shape[0]))
        assert(Y_images.shape[0] == (y_train.shape[0] + y_dev.shape[0] + y_test.shape[0]))

        return x_train, y_train, x_dev, y_dev, x_test, y_test


def save_results(directory, model_name, history):
        '''
        copy the config.py file to directory/model_name/accuracy.txt
        append the results to the bottom of the file as a python block comment
        '''
        from shutil import copyfile
        filename = str(history.history['acc'][len(history.history['acc'])-1])
        copyfile('./config.py', directory + '/' + model_name + '/' +
                 filename + ".txt")
        f = open(directory + '/' + model_name + '/' +  filename + '.txt', 'a+')
        f.write('\'\'\'')
        f.write("\n\nresults: \n\n")
        for i in range(0, len(history.history['loss'])): 
                f.write('Epoch ' + str(i + 1) + '/' +
                        str(len(history.history['loss'])) + '\n')
                f.write('loss; ' + str(history.history['loss'][i]) + ' -  ')
                f.write('acc; ' + str(history.history['acc'][i]) + ' - \n')
                f.write('val_loss; ' +
                        str(history.history['val_loss'][i]) + ' - ')
                f.write('val_acc; ' +
                        str(history.history['val_acc'][i]) + '\n\n')

        f.write('\'\'\'')
        f.close()

def initialize_output_directory(directory, model_name):
        if not os.path.exists(directory):
                os.makedirs(directory)
        if not os.path.exists(directory + '/' + model_name):
                os.makedirs(directory + '/' + model_name)

def parse_config_file():
        loaded_params = {}
        loaded_params['model_name'] = config.model_name
        loaded_params['num_epochs'] = config.num_epochs
        loaded_params['batch_size'] = config.batch_size
        loaded_params['ratio_train'] = config.ratio_train
        loaded_params['ratio_test'] = config.ratio_test
        loaded_params['learning_rate'] = config.learning_rate
        loaded_params['output_directory'] = config.output_directory
        loaded_params['optimizer'] = config.optimizer
        loaded_params['image_directory'] = config.image_directory
        
        return loaded_params
